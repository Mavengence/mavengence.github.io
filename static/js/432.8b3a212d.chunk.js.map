{"version":3,"file":"static/js/432.8b3a212d.chunk.js","mappings":"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","sources":["components/ui/QuantumCircuits.js","components/ui/QuantumBackground.js"],"sourcesContent":["import React, { useEffect, useRef } from 'react';\nimport styled from 'styled-components';\n\n/**\n * Container for the quantum circuit animation\n * Creates a subtle network visualization overlaying the background\n */\nconst CircuitsContainer = styled.div`\n  position: fixed;\n  top: 0;\n  left: 0;\n  width: 100%;\n  height: 100%;\n  z-index: 2;\n  pointer-events: none; /* Allow clicks to pass through */\n  overflow: hidden;\n  opacity: 0.12; /* Subtle visual layer */\n`;\n\n/**\n * Canvas element for rendering quantum circuit animation\n * Uses hardware acceleration for smoother rendering\n */\nconst CircuitsCanvas = styled.canvas`\n  position: absolute;\n  top: 0;\n  left: 0;\n  width: 100%;\n  height: 100%;\n  transform: translateZ(0); /* GPU acceleration for better performance */\n  will-change: transform; /* Performance optimization hint */\n`;\n\n/**\n * QuantumCircuits component\n * Renders a network of interconnected nodes with data flow animations\n * Simulates quantum circuit pathways with pulsing nodes\n */\nconst QuantumCircuits = () => {\n  // Canvas and animation control references\n  const canvasRef = useRef(null);\n  const animationRef = useRef(null);\n  const lastFrameTimeRef = useRef(0);\n  \n  // Performance optimization with frame rate limiting\n  const FPS = 24; // Lower FPS than primary animation for resource efficiency\n  const frameInterval = 1000 / FPS;\n\n  useEffect(() => {\n    const canvas = canvasRef.current;\n    const ctx = canvas.getContext('2d', { alpha: false }); // Disable alpha for better performance\n    let width, height;\n    let resizeTimeout = null;\n    \n    // Debounced resize handler for better performance\n    const handleResize = () => {\n      if (resizeTimeout) clearTimeout(resizeTimeout);\n      \n      resizeTimeout = setTimeout(() => {\n        width = window.innerWidth;\n        height = window.innerHeight;\n        canvas.width = width;\n        canvas.height = height;\n      }, 150); // 150ms debounce\n    };\n    \n    window.addEventListener('resize', handleResize);\n    \n    // Initial setup\n    width = window.innerWidth;\n    height = window.innerHeight;\n    canvas.width = width;\n    canvas.height = height;\n    \n    // Circuit nodes and connections\n    const nodes = [];\n    const connections = [];\n    const nodeCount = Math.max(5, Math.floor(width * height / 150000)); // Adjust density based on screen size\n    \n    // Generate nodes (quantum circuit intersections)\n    for (let i = 0; i < nodeCount; i++) {\n      nodes.push({\n        x: Math.random() * width,\n        y: Math.random() * height,\n        size: 1.5 + Math.random() * 3,\n        pulseSize: 0,\n        maxPulseSize: 20 + Math.random() * 30,\n        pulsing: false,\n        pulseSpeed: 0.3 + Math.random() * 0.7,\n        pulseDelay: 1000 + Math.random() * 15000, // Random delay before pulsing\n        lastPulse: 0,\n        color: Math.random() > 0.7 ? \n          `rgba(130, 90, 230, 0.8)` : // Purple\n          Math.random() > 0.5 ?\n            `rgba(30, 180, 220, 0.8)` : // Blue\n            `rgba(0, 210, 180, 0.8)`, // Teal\n        connections: []\n      });\n    }\n    \n    // Generate connections between nodes (quantum circuit paths)\n    nodes.forEach((node, i) => {\n      // Each node connects to 1-3 other nodes\n      const connectionCount = 1 + Math.floor(Math.random() * 3);\n      \n      for (let j = 0; j < connectionCount; j++) {\n        // Find a node to connect to (avoid connecting to self)\n        const candidates = nodes.filter(n => n !== node && !node.connections.includes(n));\n        \n        if (candidates.length > 0) {\n          // Find the closest nodes that aren't already connected\n          candidates.sort((a, b) => {\n            const distA = Math.hypot(node.x - a.x, node.y - a.y);\n            const distB = Math.hypot(node.x - b.x, node.y - b.y);\n            return distA - distB;\n          });\n          \n          // Connect to one of the closest nodes (not always the closest for variety)\n          const targetIndex = Math.min(Math.floor(Math.random() * 3), candidates.length - 1);\n          const target = candidates[targetIndex];\n          \n          // Add to connections list\n          node.connections.push(target);\n          target.connections.push(node);\n          \n          // Create connection object\n          connections.push({\n            start: node,\n            end: target,\n            dataPoints: [],\n            speed: 0.5 + Math.random() * 2,\n            frequency: 500 + Math.random() * 5000, // Time between data packets\n            lastDataSent: -(Math.random() * 5000), // Randomize initial timing\n            direction: Math.random() > 0.5 ? 1 : -1, // Random direction\n            active: Math.random() > 0.3, // Some connections start inactive\n            width: 1 + Math.random()\n          });\n        }\n      }\n    });\n    \n    /**\n     * DataPacket class\n     * Represents data moving along network connections between nodes\n     * Creates visual effect of information flow in the quantum network\n     */\n    class DataPacket {\n      /**\n       * Create a new data packet\n       * @param {Object} connection - Connection object this packet travels on\n       * @param {number} direction - Direction of travel (1 = start→end, -1 = end→start)\n       * @param {number} size - Visual size of the packet\n       */\n      constructor(connection, direction, size = 2) {\n        this.connection = connection;\n        this.direction = direction;\n        this.progress = direction > 0 ? 0 : 1; // Position along path (0=start, 1=end)\n        this.size = size;\n        this.speed = 0.003 + Math.random() * 0.006; // Randomized travel speed\n        this.color = connection.start.color; // Inherit color from source node\n        this.alive = true; // Tracking for removal when reaching destination\n      }\n      \n      /**\n       * Update packet position along its path\n       * @param {number} timeFactor - Time normalization factor for frame-rate independence\n       */\n      update(timeFactor = 1) {\n        // Move along the connection with normalized speed\n        this.progress += this.speed * this.direction * timeFactor;\n        \n        // Handle packet reaching either end of the connection\n        if (this.progress <= 0 || this.progress >= 1) {\n          // Determine which node was reached and trigger pulse effect\n          const node = this.progress <= 0 ? this.connection.start : this.connection.end;\n          node.pulsing = true;\n          node.pulseSize = 0;\n          \n          // Mark for removal from the system\n          this.alive = false;\n        }\n      }\n      \n      /**\n       * Render the data packet\n       * @param {CanvasRenderingContext2D} ctx - Canvas rendering context\n       */\n      draw(ctx) {\n        const start = this.connection.start;\n        const end = this.connection.end;\n        \n        // Calculate current position by linear interpolation\n        const x = start.x + (end.x - start.x) * this.progress;\n        const y = start.y + (end.y - start.y) * this.progress;\n        \n        // Draw the main packet circle\n        ctx.beginPath();\n        ctx.arc(x, y, this.size, 0, Math.PI * 2);\n        ctx.fillStyle = this.color;\n        ctx.fill();\n        \n        // Add inner glow effect for visual depth\n        ctx.shadowColor = this.color;\n        ctx.shadowBlur = 5;\n        ctx.beginPath();\n        ctx.arc(x, y, this.size * 0.7, 0, Math.PI * 2);\n        ctx.fill();\n        ctx.shadowBlur = 0; // Reset shadow to avoid affecting other elements\n      }\n    }\n    \n    /**\n     * Main animation loop\n     * Renders and updates the quantum circuit network visualization\n     * Uses frame rate limiting for consistent performance\n     * \n     * @param {number} timestamp - Current animation timestamp\n     */\n    const animate = (timestamp) => {\n      // Apply frame rate limiting to reduce CPU usage\n      const elapsed = timestamp - lastFrameTimeRef.current;\n      if (elapsed < frameInterval) {\n        animationRef.current = requestAnimationFrame(animate);\n        return;\n      }\n      lastFrameTimeRef.current = timestamp - (elapsed % frameInterval);\n      \n      // Create fading trail effect with semi-transparent overlay\n      ctx.fillStyle = 'rgba(0, 0, 0, 0.1)';\n      ctx.fillRect(0, 0, width, height);\n      \n      // Calculate time factor for frame-rate independent motion\n      // Ensures consistent animation speed regardless of device performance\n      const timeFactor = elapsed / 16.67; // Normalized to 60fps baseline\n      \n      // Update and draw connections\n      connections.forEach(connection => {\n        const start = connection.start;\n        const end = connection.end;\n        \n        // Draw connection line\n        ctx.beginPath();\n        ctx.moveTo(start.x, start.y);\n        ctx.lineTo(end.x, end.y);\n        ctx.strokeStyle = `rgba(50, 130, 240, ${connection.active ? 0.3 : 0.1})`;\n        ctx.lineWidth = connection.width;\n        ctx.stroke();\n        \n        // Check if it's time to send a new data packet\n        if (connection.active && timestamp - connection.lastDataSent > connection.frequency) {\n          connection.lastDataSent = timestamp;\n          \n          // Create a new data packet\n          connection.dataPoints.push(\n            new DataPacket(connection, connection.direction, 1.5 + Math.random())\n          );\n          \n          // Occasionally reverse direction\n          if (Math.random() > 0.85) {\n            connection.direction *= -1;\n          }\n        }\n        \n        // Update and draw data packets with time factor\n        connection.dataPoints = connection.dataPoints.filter(packet => {\n          if (packet.alive) {\n            packet.update(timeFactor);\n            packet.draw(ctx);\n            return true;\n          }\n          return false;\n        });\n        \n        // Randomly activate/deactivate connections\n        if (Math.random() > 0.997) {\n          connection.active = !connection.active;\n        }\n      });\n      \n      // Update and draw nodes\n      nodes.forEach(node => {\n        // Draw node\n        ctx.beginPath();\n        ctx.arc(node.x, node.y, node.size, 0, Math.PI * 2);\n        ctx.fillStyle = node.color.replace('0.8', '0.6');\n        ctx.fill();\n        \n        // Handle pulsing effect\n        if (node.pulsing) {\n          node.pulseSize += node.pulseSpeed * timeFactor;\n          \n          // Draw pulse\n          ctx.beginPath();\n          ctx.arc(node.x, node.y, node.pulseSize, 0, Math.PI * 2);\n          const alpha = Math.max(0, 0.5 - node.pulseSize / node.maxPulseSize);\n          ctx.strokeStyle = node.color.replace('0.8', alpha.toString());\n          ctx.lineWidth = 1;\n          ctx.stroke();\n          \n          // End pulse when it gets too big\n          if (node.pulseSize > node.maxPulseSize) {\n            node.pulsing = false;\n            \n            // Randomly activate one of its connections\n            if (node.connections.length > 0 && Math.random() > 0.3) {\n              const randomConnection = connections.find(c => \n                (c.start === node || c.end === node) && !c.active\n              );\n              \n              if (randomConnection) {\n                randomConnection.active = true;\n              }\n            }\n          }\n        } else if (Math.random() > 0.998) {\n          // Occasionally pulse randomly\n          node.pulsing = true;\n          node.pulseSize = 0;\n        }\n      });\n      \n      animationRef.current = requestAnimationFrame(animate);\n    };\n    \n    // Start animation\n    animationRef.current = requestAnimationFrame(animate);\n    \n    // Cleanup\n    return () => {\n      window.removeEventListener('resize', handleResize);\n      if (animationRef.current) {\n        cancelAnimationFrame(animationRef.current);\n      }\n    };\n  }, [frameInterval]); // Include frameInterval as dependency\n\n  return (\n    <CircuitsContainer>\n      <CircuitsCanvas ref={canvasRef} />\n    </CircuitsContainer>\n  );\n};\n\n// Use React.memo to prevent unnecessary re-renders\nexport default React.memo(QuantumCircuits);","import React, { useEffect, useRef } from 'react';\nimport styled from 'styled-components';\nimport QuantumCircuits from './QuantumCircuits';\n\n/**\n * Container for the quantum-inspired background elements\n * Fixed positioning ensures it covers the entire viewport\n */\nconst QuantumBackgroundContainer = styled.div`\n  position: fixed;\n  top: 0;\n  left: 0;\n  width: 100%;\n  height: 100%;\n  z-index: 1;\n  pointer-events: none; /* Allow clicks to pass through */\n  overflow: hidden;\n`;\n\n/**\n * Canvas element for rendering digital rain effect\n * Uses hardware acceleration for better performance\n */\nconst QuantumCanvas = styled.canvas`\n  position: absolute;\n  top: 0;\n  left: 0;\n  width: 100%;\n  height: 100%;\n  opacity: 0.13; /* Subtle visibility for background effect */\n  transform: translateZ(0); /* Force GPU acceleration */\n  will-change: transform; /* Performance hint for browsers */\n`;\n\n/**\n * Quantum-inspired background component\n * Renders dynamic \"digital rain\" effect with mathematical symbols\n */\nconst QuantumBackground = () => {\n  // Refs for canvas access and animation control\n  const canvasRef = useRef(null);\n  const animationRef = useRef(null);\n  const lastFrameTimeRef = useRef(0);\n  \n  // Frame rate control for performance optimization\n  const FPS = 30; // Balances visual smoothness with CPU usage\n  const frameInterval = 1000 / FPS;\n\n  useEffect(() => {\n    const canvas = canvasRef.current;\n    const ctx = canvas.getContext('2d', { alpha: false }); // Disable alpha for better performance\n    let width, height;\n    let resizeTimeout = null;\n    \n    /**\n     * Debounced resize handler\n     * Prevents excessive canvas resizing during window resize events\n     * Improves performance by delaying resize until user finishes resizing\n     */\n    const handleResize = () => {\n      if (resizeTimeout) clearTimeout(resizeTimeout);\n      \n      resizeTimeout = setTimeout(() => {\n        width = window.innerWidth;\n        height = window.innerHeight;\n        canvas.width = width;\n        canvas.height = height;\n      }, 150); // 150ms throttle delay\n    };\n    \n    window.addEventListener('resize', handleResize);\n    \n    // Initial canvas sizing\n    width = window.innerWidth;\n    height = window.innerHeight;\n    canvas.width = width;\n    canvas.height = height;\n    \n    /**\n     * Character sets for the digital rain effect\n     * Different categories create visual variety and thematic consistency\n     */\n    const binaryDigits = ['0', '1']; // Binary data representation\n    const quantumSymbols = ['ψ', 'Φ', 'Ω', 'σ', 'π', 'λ', 'Δ', '∇', '∫', '∑', '∞']; // Physics/math symbols\n    const equations = ['E=mc²', 'ψ|H|ψ', 'h/2π', 'Δx·Δp≥ℏ/2', '|ψ⟩', '⟨φ|ψ⟩', 'e^iθ']; // Scientific formulas\n    const dataTerms = ['01', '10', 'NaN', '404', 'ML', 'AI', '+1', '-1', 'px']; // Tech/data terms\n    \n    /**\n     * Digital rain column configuration\n     * Each column represents a vertical stream of falling characters\n     */\n    const columns = [];\n    const columnCount = Math.floor(width / 20); // Character density based on screen width\n    \n    /**\n     * Initialize columns with randomized properties\n     * Creates visual variety in the animation pattern\n     */\n    for (let i = 0; i < columnCount; i++) {\n      columns.push({\n        x: i * 20, // Horizontal position\n        y: Math.random() * height, // Random starting height\n        speed: 0.5 + Math.random() * 1.5, // Random falling speed\n        characters: [], // Will hold the characters in this column\n        lastUpdate: 0, // Timestamp tracking for character changes\n        updateInterval: 500 + Math.random() * 1000, // Random interval between character updates\n        type: Math.random() > 0.7 ? 'quantum' : Math.random() > 0.5 ? 'binary' : 'data', // Character type\n        opacity: 0.3 + Math.random() * 0.7, // Random opacity for visual depth\n        length: 5 + Math.floor(Math.random() * 15) // Random column length\n      });\n    }\n    \n    /**\n     * Color scheme for different character types\n     * Creates visual distinction between character categories\n     */\n    const colorMap = {\n      binary: `rgba(0, 180, 220, 0.7)`,   // Cyan blue for binary digits\n      quantum: `rgba(120, 80, 220, 0.8)`, // Purple for quantum/physics symbols\n      data: `rgba(220, 70, 120, 0.7)`,    // Pink for data/tech terms\n      equation: `rgba(0, 220, 150, 0.8)`  // Green for scientific equations\n    };\n    \n    // Initialize the characters for each column\n    columns.forEach(column => {\n      for (let i = 0; i < column.length; i++) {\n        let char;\n        if (column.type === 'binary') {\n          char = binaryDigits[Math.floor(Math.random() * binaryDigits.length)];\n        } else if (column.type === 'quantum') {\n          char = quantumSymbols[Math.floor(Math.random() * quantumSymbols.length)];\n        } else {\n          // 20% chance to use an equation instead of data term\n          if (Math.random() > 0.8) {\n            char = equations[Math.floor(Math.random() * equations.length)];\n            column.type = 'equation';\n          } else {\n            char = dataTerms[Math.floor(Math.random() * dataTerms.length)];\n          }\n        }\n        \n        column.characters.push({\n          value: char,\n          opacity: (1 - (i / column.length)) * column.opacity,\n          size: column.type === 'equation' ? 10 : 12\n        });\n      }\n    });\n\n    /**\n     * Main animation loop with frame rate control\n     * Manages the digital rain effect rendering with performance optimization\n     * @param {number} timestamp - Current animation timestamp from requestAnimationFrame\n     */\n    const animate = (timestamp) => {\n      // Limit frame rate to improve performance\n      const elapsed = timestamp - lastFrameTimeRef.current;\n      if (elapsed < frameInterval) {\n        animationRef.current = requestAnimationFrame(animate);\n        return;\n      }\n      lastFrameTimeRef.current = timestamp - (elapsed % frameInterval);\n      \n      // Apply fade effect by using semi-transparent black overlay\n      // Creates trailing effect as characters fall\n      ctx.fillStyle = 'rgba(0, 0, 0, 0.05)';\n      ctx.fillRect(0, 0, width, height);\n      \n      // Update and draw each column\n      columns.forEach(column => {\n        // Move the column downward\n        column.y += column.speed * (elapsed / 16.67); // Normalize motion by frame time (60fps base)\n        \n        // Reset column position when it goes out of viewport\n        if (column.y > height + column.length * 20) {\n          column.y = -column.length * 20;\n          column.speed = 0.5 + Math.random() * 1.5;\n          \n          // Occasionally change column type\n          if (Math.random() > 0.95) {\n            column.type = Math.random() > 0.7 ? 'quantum' : Math.random() > 0.5 ? 'binary' : 'data';\n            \n            // Refresh characters based on new type\n            column.characters.forEach((char, index) => {\n              if (column.type === 'binary') {\n                char.value = binaryDigits[Math.floor(Math.random() * binaryDigits.length)];\n              } else if (column.type === 'quantum') {\n                char.value = quantumSymbols[Math.floor(Math.random() * quantumSymbols.length)];\n              } else {\n                if (Math.random() > 0.8) {\n                  char.value = equations[Math.floor(Math.random() * equations.length)];\n                  column.type = 'equation';\n                } else {\n                  char.value = dataTerms[Math.floor(Math.random() * dataTerms.length)];\n                }\n              }\n              \n              char.size = column.type === 'equation' ? 10 : 12;\n            });\n          }\n        }\n        \n        // Check if it's time to update characters\n        if (timestamp - column.lastUpdate > column.updateInterval) {\n          column.lastUpdate = timestamp;\n          \n          // Randomly change one character in the column\n          const randomIndex = Math.floor(Math.random() * column.characters.length);\n          const char = column.characters[randomIndex];\n          \n          if (column.type === 'binary') {\n            char.value = binaryDigits[Math.floor(Math.random() * binaryDigits.length)];\n          } else if (column.type === 'quantum') {\n            char.value = quantumSymbols[Math.floor(Math.random() * quantumSymbols.length)];\n          } else if (column.type === 'equation') {\n            // 10% chance to change from equation to another type\n            if (Math.random() > 0.9) {\n              char.value = Math.random() > 0.5 ? \n                binaryDigits[Math.floor(Math.random() * binaryDigits.length)] : \n                dataTerms[Math.floor(Math.random() * dataTerms.length)];\n              column.type = Math.random() > 0.5 ? 'binary' : 'data';\n            } else {\n              char.value = equations[Math.floor(Math.random() * equations.length)];\n            }\n          } else {\n            // 10% chance to change to equation\n            if (Math.random() > 0.9) {\n              char.value = equations[Math.floor(Math.random() * equations.length)];\n              column.type = 'equation';\n            } else {\n              char.value = dataTerms[Math.floor(Math.random() * dataTerms.length)];\n            }\n          }\n          \n          char.size = column.type === 'equation' ? 10 : 12;\n        }\n        \n        // Draw each character in the column\n        column.characters.forEach((char, index) => {\n          const y = column.y - index * 20;\n          \n          // Only draw if visible\n          if (y > -20 && y < height + 20) {\n            ctx.font = `${char.size}px \"SF Mono\", Consolas, monospace`;\n            ctx.fillStyle = colorMap[column.type].replace(')', `, ${char.opacity})`);\n            \n            // First character gets a subtle glow effect\n            if (index === 0) {\n              ctx.shadowColor = colorMap[column.type];\n              ctx.shadowBlur = 10;\n              ctx.fillStyle = colorMap[column.type].replace(')', `, ${char.opacity * 1.3})`);\n            } else {\n              ctx.shadowBlur = 0;\n            }\n            \n            ctx.fillText(char.value, column.x, y);\n          }\n        });\n      });\n      \n      animationRef.current = requestAnimationFrame(animate);\n    };\n    \n    // Start animation\n    animationRef.current = requestAnimationFrame(animate);\n    \n    // Cleanup\n    return () => {\n      window.removeEventListener('resize', handleResize);\n      if (animationRef.current) {\n        cancelAnimationFrame(animationRef.current);\n      }\n    };\n  }, [frameInterval]); // Include frameInterval as dependency\n\n  return (\n    <QuantumBackgroundContainer>\n      <QuantumCanvas ref={canvasRef} />\n      <QuantumCircuits />\n    </QuantumBackgroundContainer>\n  );\n};\n\n// Use React.memo to prevent unnecessary re-renders\nexport default React.memo(QuantumBackground);"],"names":["CircuitsContainer","styled","div","CircuitsCanvas","canvas","QuantumCircuits","canvasRef","useRef","animationRef","lastFrameTimeRef","frameInterval","useEffect","current","ctx","getContext","alpha","width","height","resizeTimeout","handleResize","clearTimeout","setTimeout","window","innerWidth","innerHeight","addEventListener","nodes","connections","nodeCount","Math","max","floor","i","push","x","random","y","size","pulseSize","maxPulseSize","pulsing","pulseSpeed","pulseDelay","lastPulse","color","forEach","node","connectionCount","j","candidates","filter","n","includes","length","sort","a","b","hypot","target","min","start","end","dataPoints","speed","frequency","lastDataSent","direction","active","DataPacket","constructor","connection","arguments","undefined","this","progress","alive","update","timeFactor","draw","beginPath","arc","PI","fillStyle","fill","shadowColor","shadowBlur","animate","timestamp","elapsed","requestAnimationFrame","fillRect","moveTo","lineTo","strokeStyle","lineWidth","stroke","packet","replace","toString","randomConnection","find","c","removeEventListener","cancelAnimationFrame","_jsx","children","ref","React","QuantumBackgroundContainer","QuantumCanvas","QuantumBackground","binaryDigits","quantumSymbols","equations","dataTerms","columns","columnCount","characters","lastUpdate","updateInterval","type","opacity","colorMap","binary","quantum","data","equation","column","char","value","index","randomIndex","font","fillText","_jsxs"],"sourceRoot":""}